<<<<<<< HEAD
---
title: "projet Series chronologiques"
author: "Viny Presty NAKAVOUA"
date: "2024-11-06"
output: html_document
---


# 0. Objectif
On a les données d'une personne qui a réalisé une expérience
premiere phase avant regime et therapie : se pèse plusieurs fois par jour 
Deuxieme phase : se pèse une seule fois par jour durant le regime pendant deux semaines


# 1. importation des données

```{r, results='hide'}
library(readxl)
data1 <- read_excel("poids.xlsx", sheet = "Poids_phase_1")
```


```{r}
library(readxl)
data2 <- read_excel("poids.xlsx", sheet = "Poids_phase_2")
```



```{r}
# un head pour voir les 6 premières valeurs
head(data1)
```


```{r}
# un head pour voir les 6 premières valeurs
head(data2)
```



```{r}
# on le met en dataframe
data1 <- as.data.frame(data1)
```


```{r}
# on le met en dataframe
data2 <- as.data.frame(data2)
```


## 1.1 pretraitement de la variable jour:

### pour les données de la première phase

```{r}
data1$Jour <- as.Date(data1$Jour, format = "%d/%m/%y")
```


```{r}
head(data1)
```


### pour les données de la deuxième phase

```{r}
data2$Jour <- as.Date(data2$Jour)
```


```{r}
head(data2)
```


```{r}
## view des deux datasets
View(data1)
View(data2)
```


## 1.2 pretraitement de la variable Poids:

### pour les données de la première phase

```{r}
any(is.na(data1$Poids))
```


#### choix de la méthode d'imputation :

  on remarque que les données observées ne varient pas beaucoup (entre 99 et 100 kg environ), ce qui est normal car une personne qui n'est pas malade ne perd pas plusieurs kg en une journée.
  Du coup, l'imputation devient facile car on pourrait imputer par la médiane selon le jour, c'est-à-dire, la valeur manquante d'un jour sera remplacée par le poids médian du même jour.

on a pensé à cela mais c'est pas très bon parce que

```{r}
# Imputation des valeurs manquantes par la médiane journalière
library(dplyr)
data1 <- data1 %>%
  group_by(Jour) %>%
  mutate(Poids = ifelse(is.na(Poids), mean(Poids, na.rm = TRUE), Poids))

```



```{r}
any(is.na(data1$Poids)) # Vérifie si des valeurs manquantes existent dans Poids
```

```{r}
is.numeric(data1$Poids)
```


### pour les données de la deuxième phase

```{r}
any(is.na(data2$Poids))
```

il n'y a pas de na donc pas de pretraitement à faire ici.


## 1.3 pretraitement de la variable Heure:

### pour les données de la première phase

```{r}
is.numeric(data1$Heure) # ce ne sont pas des données numériques
any(is.na(data1$Heure)) # il y a des na
```


```{r}
library(hms)
data1$Heure <- as_hms(strptime(gsub("h", ":", data1$Heure), format = "%H:%M"))

```



```{r}
# convertissons les heures en format décimal
data1$Heure <- ifelse(is.na(data1$Heure), NA, as.numeric(format(strptime(data1$Heure, "%H:%M"), "%H")) +
                           as.numeric(format(strptime(data1$Heure, "%H:%M"), "%M")) / 60)

```



```{r}
# imputons les heures manquantes
# l'idée ici est de trouver le mean des heures les plus proches : c'est la métode d'interpolation
# Installer le package "zoo" si nécessaire
library(zoo)

# Fonction pour interpoler les NA par la moyenne des voisins
data1$Heure <- zoo::na.approx(data1$Heure, na.rm = FALSE)

```



### pour les données de la deuxième phase

```{r}
is.numeric(data2$Heure) # ce ne sont pas des données numériques
any(is.na(data2$Heure)) # il n'y a pas des na
```


```{r}
library(hms)
data2$Heure <- as_hms(strptime(gsub("h", ":", data2$Heure), format = "%H:%M"))

```


```{r}
# convertissons les heures en format décimal
data2$Heure <- ifelse(is.na(data2$Heure), NA, as.numeric(format(strptime(data2$Heure, "%H:%M"), "%H")) +
                           as.numeric(format(strptime(data2$Heure, "%H:%M"), "%M")) / 60)

```



## 1.3 plotting des variables de l'étude :

### pour les données de la première phase


```{r}
plot(x=data1$Heure, y=data1$Poids)
```

cette donnée à 0h doit etre mis en fin de journée comme 0h = 24h

```{r}
which(data1$Heure == 0)
```

```{r}
data1$Heure[48] = 24
```




### pour les données de la deuxième phase

```{r}
plot(x=data2$Heure, y=data2$Poids)
```



# 2. Lissage par la méthode de regression locale : le poids en fonction de la variable heure

## 2.1 modélisation des différences de poids sans tenir compte du jour, cela donne la variable de poids


```{r}
res_loess <- loess(Poids~Heure,data=data1,span = 0.3)
```


```{r}
## ajoutons une colonne des valeurs ajustées dans le data1frame
data1$y <- res_loess$fitted
```



```{r}
## representation graphique
library(ggplot2)
ggplot(data1,aes(x=Heure,y=Poids)) +
geom_point() +
geom_line(aes(y=y),col="red",size=1)

```



# 3.Calculez l’évolution du poids pendant la seconde phase indépendamment des variations dans la journée.

comme dans la consigne, 
 104.7kg effectuée à 18h50
 on va chercher la valeur lissée à 18h50 donc y dans data1 quand heure = 18h50
 et  la valeur à midi de la série lissée
 puis trouver l'ecart entre les deux.
 puisqu’on a observé 104.7kg à 18h50, on peut en déduire que le poids à midi sur cette journée sera 104.7 kg +- cet ecart.
 
 

```{r}
which(data1$Heure) = 12
valeur_midi <- data1$
```



















=======
---
title: "projet Series chronologiques"
author: "Viny Presty NAKAVOUA"
date: "2024-11-06"
output: html_document
---


# 0. Objectif
On a les données d'une personne qui a réalisé une expérience
premiere phase avant regime et therapie : se pèse plusieurs fois par jour 
Deuxieme phase : se pèse une seule fois par jour durant le regime pendant deux semaines


# 1. importation des données

```{r, results='hide'}
library(readxl)
data <- read_excel("poids.xlsx")
```


```{r}
head(data)
```


```{r}
data <- as.data.frame(data)
```

```{r}
data$Jour <- as.Date(data$Jour, format = "%d/%m/%y")
```

```{r}
head(data)
```


## 1.1 pretraitement de la variable Poids:

```{r}
View(data)
```


### choix de la méthode d'imputation :

  on remarque que les données observées ne varient pas beaucoup (entre 99 et 100 kg environ), ce qui est normal car une personne qui n'est pas malade ne perd pas plusieurs kg en une journée.
  Du coup, l'imputation devient facile car on pourrait imputer par la médiane selon le jour, c'est-à-dire, la valeur manquante d'un jour sera remplacée par le poids médian du même jour.



```{r}
# Imputation des valeurs manquantes par la médiane journalière
library(dplyr)
data <- data %>%
  group_by(Jour) %>%
  mutate(Poids = ifelse(is.na(Poids), median(Poids, na.rm = TRUE), Poids))

```



```{r}
any(is.na(data$Poids)) # Vérifie si des valeurs manquantes existent dans Poids
```

```{r}
is.numeric(data$Poids)
```


## 1.2 pretraitement de la variable Heure:

```{r}
is.numeric(data$Heure) # ce ne sont pas des données numériques
any(is.na(data$Heure)) # il y a des na
```


```{r}
library(hms)
data$Heure <- as_hms(strptime(gsub("h", ":", data$Heure), format = "%H:%M"))

```


```{r}
mode(data$Heure)
```

```{r}
# convertissons les heures en format décimal
data$Heure <- ifelse(is.na(data$Heure), NA, as.numeric(format(strptime(data$Heure, "%H:%M"), "%H")) +
                           as.numeric(format(strptime(data$Heure, "%H:%M"), "%M")) / 60)

```



```{r}
# imputons les heures manquantes
# l'idée ici est de trouver le mean des heures les plus proches : c'est la métode d'interpolation
# Installer le package "zoo" si nécessaire
library(zoo)

# Fonction pour interpoler les NA par la moyenne des voisins
data$Heure <- zoo::na.approx(data$Heure, na.rm = FALSE)

```



## 1.3 plotting des variables de l'étude :

```{r}
plot(x=data$Heure, y=data$Poids)
```


Avec un tel nuage de point, je pense qu'on doit transformer les données, en appliquant une fonction


# 2. Lissage par la méthode de regression locale : le poids en fonction de la variable heure

```{r}
res_loess <- loess(Poids~Heure,data=data,span = 0.7)
```


```{r}
## ajoutons une colonne des valeurs ajustées dans le dataframe
data$y <- res_loess$fitted
```



```{r}
## representation graphique
library(ggplot2)
ggplot(data,aes(x=Heure,y=Poids)) +
geom_point() +
geom_line(aes(y=y),col="red",size=1)

```






>>>>>>> 4c19c70b6a0c70a29ed6fa6573df5af1c74556bd
